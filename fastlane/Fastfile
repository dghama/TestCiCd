require 'pathname'

default_platform(:android)

before_all do
  @package = load_json(json_path: "package.json")
  @environment = ENV["ENVIRONMENT"] || "staging"
  @app_name = @package['name']
  @platform = ENV["PLATFORM"]
  @versionName = ENV["VERSION_NAME"]

  puts "Loaded package: #{@package}"
  puts "Environment: #{@environment}"
  puts "App Name: #{@app_name}"
  puts "Platform: #{@platform}"
end

def project_dir
  Pathname.new(File.expand_path('..', Dir.pwd))
end

def android_dir
  project_dir.join('android')
end

def ios_dir
  project_dir.join('ios')
end

def gradle_file
  android_dir.join('app', 'build.gradle')
end

def increment_version_code
  gradle_file_path = android_dir.join('app', 'build.gradle').to_s
  gradle_file_content = File.read(gradle_file_path)

  current_version_code = gradle_file_content.match(/versionCode\s+(\d+)/)[1].to_i
  new_version_code = current_version_code + 1
  updated_gradle_file_content = gradle_file_content.gsub(/versionCode\s+\d+/, "versionCode #{new_version_code}")

  if @versionName
    updated_gradle_file_content = updated_gradle_file_content.gsub(/versionName\s+"[^"]*"/, "versionName \"#{@versionName}.#{new_version_code}\"")
  else
    current_version_name = gradle_file_content.match(/versionName\s+"([^"]*)"/)[1]
    new_version_name = "#{current_version_name}.#{new_version_code}"
    updated_gradle_file_content = updated_gradle_file_content.gsub(/versionName\s+"[^"]*"/, "versionName \"#{new_version_name}\"")
  end

  File.write(gradle_file_path, updated_gradle_file_content)

  package_json_path = project_dir.join('package.json')
  package_json = JSON.parse(File.read(package_json_path))
  package_json['version'] = @versionName || new_version_name
  File.write(package_json_path, JSON.pretty_generate(package_json))
  
  new_version_code
end

def get_android_version_code
  gradle_file_path = android_dir.join('app', 'build.gradle').to_s
  gradle_file = File.read(gradle_file_path)
  gradle_file.match(/versionCode\s+(\d+)/)[1]
end

def get_android_version_name
  gradle_file_path = android_dir.join('app', 'build.gradle').to_s
  gradle_file = File.read(gradle_file_path)
  version_name_match = gradle_file.match(/versionName\s+"(.+)"/)
  if version_name_match
    version_name_match[1]
  else
    UI.error("Could not find versionName in #{gradle_file_path}")
    nil
  end
end

platform :ios do
  desc 'iOS: Increment build number'
  private_lane :inc_ver_ios do
    increment_build_number(
      xcodeproj: "./ios/#{@package['name']}.xcodeproj"
    )
  end

  lane :import_certs do
    create_keychain(
      name: "build.keychain",
      password: "temporary_password",
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    import_certificate(
      certificate_path: "distribution.p12",
      certificate_password: ENV["P12_PASSWORD"],
      keychain_name: "build.keychain",
      keychain_password: "temporary_password"
    )

    install_provisioning_profile(
      path: "profile.mobileprovision"
    )
  end

  desc 'Build the iOS app'
  lane :build do
    inc_ver_ios

      import_certs
  
  
      cocoapods(
        clean_install: true,
        podfile: "./ios/Podfile"
      )
  
      # Get the current build number
    build_number = get_build_number(xcodeproj: "./ios/#{@package['name']}.xcodeproj")
    
    # Define custom file names
    ipa_name = "#{@app_name}_#{@environment}_#{@versionName || get_version_number(xcodeproj: "./ios/#{@package['name']}.xcodeproj")}_#{build_number}.ipa"
    plist_name = "#{@app_name}_#{@environment}_#{@versionName || get_version_number(xcodeproj: "./ios/#{@package['name']}.xcodeproj")}_#{build_number}.plist"

    build_app(
      configuration: ENV["ENVIRONMENT"],
      workspace: "./ios/#{@package['name']}.xcworkspace",
      scheme: @package['name'],
      output_name: ipa_name,
      output_directory: "./ios/build",
      export_method: "ad-hoc",
      export_options: {
        method: "ad-hoc",
        provisioningProfiles: {
          "com.mobelite.testRNcicd" => "RNTestProfile"
        },
        signingStyle: "manual",
        generateAppStoreInformation: true,
      },
      xcargs: "-allowProvisioningUpdates",
      export_xcargs: "-allowProvisioningUpdates"
    )
  
     # Rename the generated plist file
     default_plist_path = "./ios/build/#{@package['name']}.plist"
     custom_plist_path = "./ios/build/#{plist_name}"
     File.rename(default_plist_path, custom_plist_path) if File.exist?(default_plist_path)
 
     UI.success "Generated IPA: #{ipa_name}"
     UI.success "Generated Plist: #{plist_name}"
    end
  end


platform :android do
  desc 'Increment versionCode and set versionName to package.json version.'
  private_lane :inc_ver_and do
    increment_version_code
  end

  version_code = get_android_version_code
  version_name = get_android_version_name
    # Define custom file names
    apk_name = "#{@app_name}_#{@environment}_#{version_name}_#{version_code}.apk"
    json_name = "#{@app_name}_#{@environment}_#{version_name}_#{version_code}.json"
  desc 'Build the Android app'
  lane :build do
    inc_ver_and
    gradle(
      task: "clean assembleRelease",
      project_dir: "android/",
      properties: {
        "output.name" => "#{@app_name}-#{@environment}",
        "android.injected.signing.store.file" => ENV["ANDROID_KEYSTORE_FILE"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      },
      print_command: true
    )
      # Rename the generated APK
      default_apk_path = "./android/app/build/outputs/apk/release/app-release.apk"
      custom_apk_path = "./android/app/build/outputs/apk/release/#{apk_name}"
      File.rename(default_apk_path, custom_apk_path) if File.exist?(default_apk_path)
  
      # Generate and save metadata JSON
      metadata = {
        appName: @app_name,
        environment: @environment,
        versionName: version_name,
        versionCode: version_code,
        buildTime: Time.now.utc.iso8601
      }
      File.write("./android/app/build/outputs/apk/release/#{json_name}", JSON.pretty_generate(metadata))
  
      UI.success "Generated APK: #{apk_name}"
      UI.success "Generated Metadata JSON: #{json_name}"
  end
end

# Update the upload lane to use the new file names
desc 'Upload the app to the MStore'
lane :upload_app_to_mstore do
  if @platform == 'ios'
    build_number = get_build_number(xcodeproj: "./ios/#{@package['name']}.xcodeproj")
    version = @versionName || get_version_number(xcodeproj: "./ios/#{@package['name']}.xcodeproj")
    build_file = "#{@app_name}_#{@environment}_#{version}_#{build_number}.ipa"
    info_file = "#{@app_name}_#{@environment}_#{version}_#{build_number}.plist"
  elsif @platform == 'android'
    version_code = get_android_version_code
    version_name = get_android_version_name
    build_file = "#{@app_name}_#{@environment}_#{version_name}_#{version_code}.apk"
    info_file = "#{@app_name}_#{@environment}_#{version_name}_#{version_code}.json"
  else
    UI.user_error!("Invalid platform. Use 'ios' or 'android'.")
  end

  mstore_upload_app(
    authorization: ENV['AUTHORIZATION'],
    app_dev_token: ENV['APP_DEV_TOKEN'],
    info_file: info_file,
    build_file: build_file
  )
end
