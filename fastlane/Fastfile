# Fastfile

require 'pathname'
require 'json'

default_platform(:android)

before_all do
  @package = load_json(json_path: "package.json")
  @environment = ENV["ENVIRONMENT"] || "staging"
  @version_type = ENV["VERSION_TYPE"] || "patch"
  @app_name = @package['name']

  puts "Loaded package: #{@package}"
  puts "Environment: #{@environment}"
  puts "Version Type: #{@version_type}"
  puts "App Name: #{@app_name}"
end

def project_dir
  Pathname.new(File.expand_path('..', Dir.pwd))
end

def android_dir
  project_dir.join('android')
end

def ios_dir
  project_dir.join('ios')
end

def gradle_file
  android_dir.join('app', 'build.gradle')
end

def generate_version_string(version)
  version_str = version.to_s.strip
  version_str = @package['version'] if version_str.empty?
  
  case @environment
  when "prod"
    "#{@app_name}-#{version_str}"
  when "staging"
    "#{@app_name}-#{version_str}-rc"
  when "dev"
    "#{@app_name}-#{version_str}-dev"
  when "beta"
    "#{@app_name}-#{version_str}-beta"
  else
    "#{@app_name}-#{version_str}-#{@environment}"
  end
end

def version_data_file
  project_dir.join('version_data.json')
end

def load_version_data
  if File.exist?(version_data_file)
    JSON.parse(File.read(version_data_file))
  else
    { 'ios' => {}, 'android' => {} }
  end
end
def get_android_version_name
  gradle_file_path = android_dir.join('app', 'build.gradle').to_s
  gradle_file = File.read(gradle_file_path)
  version_name_match = gradle_file.match(/versionName\s+"(.+)"/)
  version_name_match ? version_name_match[1] : nil
end

def get_android_version_code
  gradle_file_path = android_dir.join('app', 'build.gradle').to_s
  gradle_file = File.read(gradle_file_path)
  version_code_match = gradle_file.match(/versionCode\s+(\d+)/)
  version_code_match ? version_code_match[1].to_i : nil
end
def save_version_data(version_data)
  File.write(version_data_file, JSON.pretty_generate(version_data))
end

def set_version_data(platform, environment, version)
  version_data = load_version_data
  version_data[platform][environment] = version.to_i
  save_version_data(version_data)
  puts "Set #{platform} version for #{environment} to #{version}"
end

def get_version_data(platform, environment)
  version_data = load_version_data
  version_data.dig(platform, environment) || 0
end

def increment_version_data(platform)
  current_version = get_version_data(platform, @environment)
  new_version = current_version + 1
  set_version_data(platform, @environment, new_version)
  new_version
end

platform :ios do
  desc 'iOS: Increment build number and set the version to package.json version.'
  private_lane :inc_ver_ios do
    new_build_number = increment_version_data('ios')

    new_version = increment_version_number(
      xcodeproj: ios_dir.join("#{@app_name}.xcodeproj"),
      version_number: @package['version']
    )

    new_version_with_app_name = generate_version_string(new_version)

    increment_version_number(
      xcodeproj: ios_dir.join("#{@app_name}.xcodeproj"),
      version_number: new_version_with_app_name
    )

    increment_build_number(
      xcodeproj: ios_dir.join("#{@app_name}.xcodeproj"),
      build_number: new_build_number
    )
  end

  desc 'Build the iOS app'
  lane :build do
    inc_ver_ios
    cocoapods(
      clean_install: true,
      podfile: ios_dir.join("Podfile").to_s,
    )
    
    version = get_version_number(xcodeproj: ios_dir.join("#{@app_name}.xcodeproj").to_s)
    build_number = get_build_number(xcodeproj: ios_dir.join("#{@app_name}.xcodeproj").to_s)
    output_dir = ios_dir.join("builds", @environment, "#{version}_#{build_number}")
    
    build_app(
      workspace: ios_dir.join("#{@app_name}.xcworkspace").to_s,
      scheme: @app_name,
      export_method: "app-store",
      output_directory: output_dir.to_s,
      output_name: "#{@app_name}.ipa",
      skip_codesigning: true
    )
    
    File.write(output_dir.join("build_info.txt"), "Version: #{version}\nBuild: #{build_number}\nEnvironment: #{@environment}")
  end
end

platform :android do
  
  desc 'Android: Increment versionCode and set versionName to package.json version.'
  private_lane :inc_ver_and do
    new_version_code = increment_version_data('android')
    
    # Update the versionCode in build.gradle
    updated_gradle_file = File.read(gradle_file).gsub(/versionCode \d+/, "versionCode #{new_version_code}")
    File.write(gradle_file, updated_gradle_file)
    
    # Generate the new versionName based on the environment
    new_version_name = generate_version_string(@package['version'])
    updated_gradle_file = File.read(gradle_file).gsub(/versionName ".*"/, "versionName \"#{new_version_name}\"")
    File.write(gradle_file, updated_gradle_file)
  end

  desc 'Build the Android app'
  lane :build do
    inc_ver_and
    
    version_name = get_android_version_name
    version_code = get_android_version_code
    output_dir = android_dir.join("builds", @environment, "#{version_name}_#{version_code}")

    FileUtils.mkdir_p(output_dir)

    gradle(
      task: "clean assembleRelease",
      project_dir: android_dir.to_s,
      properties: {
        "output.dir" => output_dir.to_s,
        "output.name" => "#{@app_name}-#{version_name}.apk",
        "android.injected.signing.store.file" => ENV["ANDROID_KEYSTORE_FILE"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      }
    )
    
    File.write(output_dir.join("build_info.txt"), "Version: #{version_name}\nBuild: #{version_code}\nEnvironment: #{@environment}")
  end
end



desc 'Set version for a specific platform and environment'
lane :set_version do |options|
  platform = options[:platform]
  environment = options[:environment]
  version = options[:version]

  unless ['ios', 'android'].include?(platform)
    UI.user_error!("Invalid platform. Use 'ios' or 'android'.")
  end

  unless version.to_i.to_s == version.to_s
    UI.user_error!("Version must be an integer.")
  end

  set_version_data(platform, environment, version)
end

desc 'Get current version for a specific platform and environment'
lane :get_version do |options|
  platform = options[:platform]
  environment = options[:environment]

  unless ['ios', 'android'].include?(platform)
    UI.user_error!("Invalid platform. Use 'ios' or 'android'.")
  end

  version = get_version_data(platform, environment)
  puts "Current #{platform} version for #{environment}: #{version}"
end

desc 'Print all version data'
lane :print_all_versions do
  version_data = load_version_data
  puts "Current version data:"
  puts JSON.pretty_generate(version_data)
end

desc 'Commit version changes'
lane :commit_version_changes do
  # Ensure we're on the correct branch
  ensure_git_branch(branch: ENV["BRANCH_NAME"] || "main")

  # Get the current versions
  ios_version = get_version_number(xcodeproj: ios_dir.join("#{@app_name}.xcodeproj").to_s)
  ios_build = get_build_number(xcodeproj: ios_dir.join("#{@app_name}.xcodeproj").to_s)
  android_version = get_android_version_name
  android_code = get_android_version_code
  
  # Commit all changes
  git_add(path: ".")
  commit_message = "Bump version to #{@package['version']} (iOS: #{ios_version} (#{ios_build}), Android: #{android_version} (#{android_code})) for #{@environment}"
  git_commit(path: ".", message: commit_message)

  # Create a tag
  add_git_tag(tag: "v#{@package['version']}-#{@environment}")

  # Push changes and tags
  push_to_git_remote
  push_git_tags

  UI.success("Successfully committed and pushed version changes")
end

# You can add additional lanes here for deployment, testing, etc.