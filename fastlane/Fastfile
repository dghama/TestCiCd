require 'pathname'
require 'json'
require 'semantic'

default_platform(:android)

before_all do
  @package = load_json(json_path: "package.json")
  @environment = ENV["ENVIRONMENT"] || "staging"
  @version_type = ENV["VERSION_TYPE"] || "patch"
  @app_name = @package['name']
  @platform = ENV["PLATFORM"]
  puts "Loaded package: #{@package}"
  puts "Environment: #{@environment}"
  puts "Version Type: #{@version_type}"
  puts "App Name: #{@app_name}"
end

def project_dir
  Pathname.new(File.expand_path('..', Dir.pwd))
end

def android_dir
  project_dir.join('android')
end

def ios_dir
  project_dir.join('ios')
end

def gradle_file
  android_dir.join('app', 'build.gradle')
end

def generate_version_string(version)
  version_str = version.to_s.strip
  
  case @environment
  when "prod"
    "#{version_str}"
  when "staging"
    "#{version_str}-rc"
  when "dev"
    "#{version_str}-dev"
  when "beta"
    "#{version_str}-beta"
  else
    "#{version_str}-#{@environment}"
  end
end

def version_data_file
  project_dir.join('version_data.json')
end

def load_version_data
  if File.exist?(version_data_file)
    JSON.parse(File.read(version_data_file))
  else
    { 'ios' => {}, 'android' => {} }
  end
end

def get_android_version_name
  gradle_file_path = android_dir.join('app', 'build.gradle').to_s
  gradle_file = File.read(gradle_file_path)
  version_name_match = gradle_file.match(/versionName\s+"(.+)"/)
  if version_name_match
    version_name_match[1]
  else
    UI.error("Could not find versionName in #{gradle_file_path}")
    nil
  end
end

def get_android_version_code
  gradle_file_path = android_dir.join('app', 'build.gradle').to_s
  gradle_file = File.read(gradle_file_path)
  version_code_match = gradle_file.match(/versionCode\s+(\d+)/)
  if version_code_match
    version_code_match[1].to_i
  else
    UI.error("Could not find versionCode in #{gradle_file_path}")
    nil
  end
end

def save_version_data(version_data)
  File.write(version_data_file, JSON.pretty_generate(version_data))
end

def set_version_data(platform, environment, version)
  version_data = load_version_data
  version_data[platform][environment] = version.to_i
  save_version_data(version_data)
  puts "Set #{platform} version for #{environment} to #{version}"
end

def get_version_data(platform, environment)
  version_data = load_version_data
  version_data.dig(platform, environment) || 0
end

def increment_version_data(platform)
  current_version = get_version_data(platform, @environment)
  new_version = current_version + 1
  set_version_data(platform, @environment, new_version)
  new_version
end

def increment_package_version
  package_json_path = project_dir.join('package.json')
  package_json = JSON.parse(File.read(package_json_path))
  current_version = Semantic::Version.new(package_json['version'])
  new_version = current_version.increment!(@version_type)
  package_json['version'] = new_version.to_s
  File.write(package_json_path, JSON.pretty_generate(package_json))
  new_version.to_s
end

platform :ios do
  desc 'iOS: Increment build number and set the version to package.json version.'
  private_lane :inc_ver_ios do
    new_package_version = increment_package_version
    new_build_number = increment_version_data(@platform)

    new_version = increment_version_number(
      xcodeproj: ios_dir.join("#{@app_name}.xcodeproj"),
      version_number: new_package_version
    )

    new_version_with_app_name = generate_version_string(new_version)

    increment_version_number(
      xcodeproj: ios_dir.join("#{@app_name}.xcodeproj"),
      version_number: new_version_with_app_name
    )

    increment_build_number(
      xcodeproj: ios_dir.join("#{@app_name}.xcodeproj"),
      build_number: new_build_number
    )

    UI.success("iOS version updated to #{new_version_with_app_name} (#{new_build_number})")
  end

  desc 'Build the iOS app'
  lane :build do
    inc_ver_ios
    cocoapods(
      clean_install: true,
      podfile: ios_dir.join("Podfile").to_s,
    )
    
    version = get_version_number(xcodeproj: ios_dir.join("#{@app_name}.xcodeproj").to_s)
    build_number = get_build_number(xcodeproj: ios_dir.join("#{@app_name}.xcodeproj").to_s)
    output_dir = ios_dir.join("builds", @environment, "#{version}_#{build_number}")
    
    build_app(
      workspace: ios_dir.join("#{@app_name}.xcworkspace").to_s,
      scheme: @app_name,
      export_method: "app-store",
      output_directory: output_dir.to_s,
      output_name: "#{@app_name}.ipa",
      skip_codesigning: true
    )
    
    File.write(output_dir.join("build_info.txt"), "Version: #{version}\nBuild: #{build_number}\nEnvironment: #{@environment}")
    
    UI.success("iOS app built successfully. IPA location: #{output_dir}/#{@app_name}.ipa")
  end
end

platform :android do
  desc 'Android: Increment versionCode and set versionName to package.json version.'
  private_lane :inc_ver_and do
    new_package_version = increment_package_version
    new_version_code = increment_version_data(@platform)
    
    # Update the versionCode and versionName in build.gradle
    gradle_file_path = gradle_file.to_s
    updated_gradle_file = File.read(gradle_file_path)
      .gsub(/versionCode\s+\d+/, "versionCode #{new_version_code}")
    
    new_version_name = generate_version_string(new_package_version)
    updated_gradle_file = updated_gradle_file
      .gsub(/versionName\s+"[^"]*"/, "versionName \"#{new_version_name}\"")
    
    File.write(gradle_file_path, updated_gradle_file)
    
    UI.success("Android version updated to #{new_version_name} (#{new_version_code})")
  end

  desc 'Build the Android app'
  lane :build do
    inc_ver_and
    
    version_name = get_android_version_name
    version_code = get_android_version_code
    
    UI.important("Building Android app with versionName: #{version_name} and versionCode: #{version_code}")
    
    output_dir = android_dir.join("builds", @environment, "#{version_name}_#{version_code}")

    FileUtils.mkdir_p(output_dir)

    gradle(
      task: "clean assembleRelease",
      project_dir: android_dir.to_s,
      properties: {
        "output.dir" => output_dir.to_s,
        "output.name" => "#{@app_name}-#{version_name}.apk",
        "android.injected.signing.store.file" => ENV["ANDROID_KEYSTORE_FILE"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      }
    )
    
    File.write(output_dir.join("build_info.txt"), "Version: #{version_name}\nBuild: #{version_code}\nEnvironment: #{@environment}")
    
    UI.success("Android app built successfully. APK location: #{output_dir}/#{@app_name}-#{version_name}.apk")
  end
end

desc 'Set version for a specific platform and environment'
lane :set_version do |options|
  platform = options[:platform]
  environment = options[:environment]
  version = options[:version]

  unless ['ios', 'android'].include?(platform)
    UI.user_error!("Invalid platform. Use 'ios' or 'android'.")
  end

  unless version.to_i.to_s == version.to_s
    UI.user_error!("Version must be an integer.")
  end

  set_version_data(platform, environment, version)
end

desc 'Get current version for a specific platform and environment'
lane :get_version do |options|
  platform = options[:platform]
  environment = options[:environment]

  unless ['ios', 'android'].include?(platform)
    UI.user_error!("Invalid platform. Use 'ios' or 'android'.")
  end

  version = get_version_data(platform, environment)
  puts "Current #{platform} version for #{environment}: #{version}"
end

desc 'Print all version data'
lane :print_all_versions do
  version_data = load_version_data
  puts "Current version data:"
  puts JSON.pretty_generate(version_data)
end

desc 'Commit version changes'
lane :commit_version_changes do
  # Ensure we're on the correct branch
  ensure_git_branch(branch: ENV["BRANCH_NAME"] || "main")

  # Get the current versions
  ios_version = get_version_number(xcodeproj: ios_dir.join("#{@app_name}.xcodeproj").to_s)
  ios_build = get_build_number(xcodeproj: ios_dir.join("#{@app_name}.xcodeproj").to_s)
  android_version = get_android_version_name
  android_code = get_android_version_code

  # Commit all changes
  git_add(path: ".")
  commit_message = "Bump version to #{@package['version']} (iOS: #{ios_version} (#{ios_build}), Android: #{android_version} (#{android_code})) for #{@environment}"
  git_commit(path: ".", message: commit_message)

  # Create a tag
  add_git_tag(tag: "v#{@package['version']}-#{@environment}")

  push_to_git_remote(
    remote: "https://x-access-token:#{ENV['GIT_TOKEN']}@github.com/dghama/TestCiCd.git",
    local_branch: "HEAD",
    remote_branch: ENV["GITHUB_REF"]&.sub("refs/heads/", "") || "main",
    tags: true
  )

  push_git_tags

  
  UI.success("Successfully committed and pushed version changes")
end