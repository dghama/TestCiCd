require 'json'
require_relative 'helpers/version_management'
require_relative 'helpers/mstore_upload'

default_platform(:android)

version_management = Fastlane::Helper::VersionManagement
u_mstore = Fastlane::Helper::UploadToMstore

before_all do
  @package = load_json(json_path: "package.json")
  @environment = ENV["ENVIRONMENT"]
  @versionName = ENV["VERSION_NAME"]
  @eventName = ENV["GITHUB_EVENT_NAME"]

  puts "Loaded package: #{@package}"
  puts "Environment: #{@environment}"
end



# Manage certs and provisioning profiles and build IOS 
platform :ios do

  lane :update_ios_version do
    version_data = version_management.load_version_data[ENV["ENVIRONMENT"]]
    update_ios_files(version_data)
    message= "'Update #{ENV['PLATFORM']} files to version #{version_data['version_name']} (#{version_data['version_code']})'"
    commit_version_changes(version_data, message)
  end

  lane :setup_certs_and_profile do
    # Access the runner temp directory and file paths
    runner_temp = ENV['RUNNER_TEMP']
    distribution_cert_path = File.join(runner_temp, 'distribution.p12')
    provisioning_profile_path = File.join(runner_temp, 'profile.mobileprovision')
    create_keychain(
      name: "build.keychain",
      password: "temporary_password",
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    import_certificate(
      certificate_path: distribution_cert_path,
      certificate_password: ENV["P12_PASSWORD"],
      keychain_name: "build.keychain",
      keychain_password: "temporary_password"
    )

    install_provisioning_profile(
      path: provisioning_profile_path
    )
  end

  lane :build do
    setup_certs_and_profile
    cocoapods(
      clean_install: true,
      podfile: "./ios/Podfile"
    )

    if @eventName == "push"
      update_ios_version
    end

    gym(
        configuration: ENV["ENVIRONMENT"],
        workspace: "./ios/#{@package['name']}.xcworkspace",
        scheme: @package['name'],
        output_name: "#{@package['name']}_V_#{ENV['VERSION_NAME']}.#{ENV['VERSION_CODE']}_#{@environment}",
        output_directory: "./ios/build",
        export_options: {
          method: "ad-hoc",
          provisioningProfiles: {
            "com.mobelite.testRNcicd" => "RNTestProfile"
          },
          signingStyle: "manual",
        },
        xcargs: "-allowProvisioningUpdates",
        export_xcargs: "-allowProvisioningUpdates"
    )
    end
end

# Build for Android
platform :android do

  lane :update_android_version do
    version_data = version_management.load_version_data[ENV["ENVIRONMENT"]]
    version_management.update_android_files(version_data)
    message= "'Update #{ENV['PLATFORM']} files to version #{version_data['version_name']} (#{version_data['version_code']})'"
    commit_version_changes(version_data,message)
  end

  lane :build do
    if @eventName == "push"
      update_android_version
    end

    gradle(
      task: "clean assembleRelease",
      project_dir: "android/",
      properties: {
        "output.name" => "#{@package['name']}_V_#{ENV['VERSION_NAME']}.#{ENV['VERSION_CODE']}_#{@environment}",
        "android.injected.signing.store.file" => ENV["ANDROID_KEYSTORE_FILE"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"],
        "archivesBaseName" => "#{@package['name']}_V_#{ENV['VERSION_NAME']}.#{ENV['VERSION_CODE']}_#{@environment}",
        "env.file" => ENV["ENVFILE"],
      },
     
      print_command: true
    )
  end
end

# Increment the version for the package json and versions.json file
lane :increment_version_pre_build do
  version_data = version_management.increment_version()
  
  # Update package.json
  version_management.update_package_json(version_data)
  message = "'Bump version to #{version_data['version_name']} (#{version_data['version_code']})'"
  # Commit changes
  commit_version_changes(version_data,message)
  
  # Output new version info
  puts "New version: #{version_data['version_name']} (#{version_data['version_code']})"
  
  # Set output for GitHub Actions
  sh "echo \"VERSION_NAME=#{version_data['version_name']}\" >> $GITHUB_OUTPUT"
  sh "echo \"VERSION_CODE=#{version_data['version_code']}\" >> $GITHUB_OUTPUT"
end

# Push to the same branch the changes of the new version
lane :push_version_changes do
  current_branch = sh("git rev-parse --abbrev-ref HEAD").strip

  # Push to the same branch
  add_git_tag(tag: "v#{ENV['VERSION_NAME']}-#{ENV['VERSION_CODE']}-#{@environment}")
  dynamic_url = version_management.get_dynamic_github_url

  # Note: i need to change the remoteurl with a dynamic variable
  push_to_git_remote(
    remote: dynamic_url,
    local_branch: "HEAD",
    remote_branch: current_branch,
    tags: true
  )
  
  UI.success("Successfully pushed version changes")
end

lane :delete_github_artifacts do

  github_repo = version_management.get_repository_info # e.g., 'username/repository'
  token = ENV['GITHUB_TOKEN'] # GitHub Personal Access Token

  artifacts_url = "https://api.github.com/repos/#{github_repo}/actions/artifacts"

  # Fetch the list of artifacts
  response = sh("curl -s -H 'Authorization: Bearer #{token}' '#{artifacts_url}'")
  artifacts = JSON.parse(response)['artifacts']

  if artifacts.nil? || artifacts.empty?
    UI.message("No artifacts found to delete.")
  else
    artifacts.each do |artifact|
      artifact_id = artifact['id']
      delete_url = "#{artifacts_url}/#{artifact_id}"
      
      # Delete each artifact and capture the response
      UI.message("Deleting artifact with ID: #{artifact_id}")
      delete_response = sh("curl -X DELETE -s -w '%{http_code}' \
        -H 'Accept: application/vnd.github+json' \
        -H 'Authorization: Bearer #{token}' \
        -H 'X-GitHub-Api-Version: 2022-11-28' \
        '#{delete_url}'")
      
      # Print the response
      if delete_response.strip == "204"
        UI.success("Successfully deleted artifact with ID: #{artifact_id}")
      else
        UI.error("Failed to delete artifact with ID: #{artifact_id}. Response code: #{delete_response}")
      end
    end
  end
end

# Upload the app to MStore
lane :upload_app_to_mstore do

    result = u_mstore.mstore_upload_app(
      authorization: ENV['AUTHORIZATION'],
      app_dev_token: ENV['APP_DEV_TOKEN'],
      info_file: ENV['INFO_FILE'],
      build_file: ENV['BUILD_FILE'],
      platform: ENV['PLATFORM']
    )
end


  # Commits the changes to the current branch.
  #
  # @param [Hash] version_data
  #   The new version data.
  # @param [String] message
  #   The commit message.
def commit_version_changes(version_data, message)
  current_branch = `git rev-parse --abbrev-ref HEAD`.strip
  ensure_git_branch(branch: current_branch)
  git_add(path: ".")
  git_commit(path: ".", message: message)
  UI.success("Successfully committed version changes but not pushed")
end


def update_ios_files(version_data)
  set_info_plist_value(
    path: "./ios/#{@package['name']}/Info.plist",
    key: "CFBundleShortVersionString",
    value: version_data['version_name']
  )
  set_info_plist_value(
    path: "./ios/#{@package['name']}/Info.plist",
    key: "CFBundleVersion",
    value: version_data['version_code'].to_s
  )
  increment_build_number(
    build_number: version_data['version_code'],
    xcodeproj: "./ios/#{@package['name']}.xcodeproj"
  )
end
